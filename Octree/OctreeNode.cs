//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;

namespace OctreeDS
{
	[Serializable]
	public class OctreeNode<T> where T : IAABBBoundedObject
    {
        public AABB Bounds { get; }
		public List<OctreeNode<T>> Children { get; }  = new List<OctreeNode<T>> ();
		public List<T> ObjectsInNode { get; } = new List<T>();
        public IEnumerable<T> ObjectsInNodeThatCanFitInSubdivision => ObjectsInNode.Where(x => SubdivisionCanContainItem(x));
		public OctreeNode<T> Parent { get; }
        public float MinDimensionOfNode { get; }
        public bool CanHaveChildren { get; }
        public int NumObjectsInChildren => Children.Sum(c => c.ObjectsInNode.Count); 
        /// <summary>
        /// How many items a node will store directly before it allows the node to be subdivided
        /// This count does not include items that could not be inserted into the subdivisions (items that intersect the lines that cut the node into subdvisions)
        /// </summary>
        const int SubdivisionThreshold = 8 - 1;
        static readonly int MergeThreshold = (int)Math.Ceiling(((float)SubdivisionThreshold) / 8);

        //mins and maxes are global, position is global. Minx and maxes adjusted based on centre
        public OctreeNode (float minDimensionOfNode,AABB nodeBounds)
		{
            //this.paren;
            Bounds = nodeBounds;

            MinDimensionOfNode = minDimensionOfNode;

            CanHaveChildren = true;

            foreach (var i in Enumerable.Range(0, 3))
            {
                if (Bounds.extents[i] * 2 < minDimensionOfNode)
                {
                    CanHaveChildren = false;
                    break;
                }
            }
        }
        
        public bool SubdivisionCanContainItem(T item)
        {
            //make sure that no axis passing through the centre of this node can split the item in two
            return !Enumerable.Range(0, 3).Any(i => item.AABB.center[i] + item.AABB.extents[i] > Bounds.center[i] && item.AABB.center[i] - item.AABB.extents[i] < Bounds.center[i]);
        }

        public bool Insert(T item, bool debugRender = false){
			AABB itemAABB = item.AABB;
			if (Bounds.Encloses (itemAABB)) {
				if (!CanHaveChildren || !SubdivisionCanContainItem(item))
                {
                    ObjectsInNode.Add(item);
                    return true;
                }
                else if (SubdivisionThreshold <= ObjectsInNodeThatCanFitInSubdivision.Count())
                {
                    ObjectsInNode.Add(item);
                    return true;
                }
                else
                {
                    if (Children.Count == 0)
                    {
                        foreach (var extent in Bounds.EnumerateExtents())
                        {
                             var newCentre = Bounds.center + extent / 2;

                            //Debug.DrawLine(newCentre, Bounds.center, Color.white, 30f);

                            Children.Add(new OctreeNode<T>(MinDimensionOfNode, new AABB(newCentre, Bounds.extents / 2)));
                        }
                    }

                    foreach (var objectToMoveToChild in ObjectsInNodeThatCanFitInSubdivision.ToList())
                    {
                        ObjectsInNode.Remove(objectToMoveToChild);

                        foreach (var child in Children)
                        {
                            if (child.Insert(objectToMoveToChild, debugRender))
                                break;
                        }
                    }


                    foreach (var child in Children)
                    {
                        if (child.Insert(item, debugRender))
                            return true;
                    }

                    throw new NotImplementedException("The item could not be inserted into this tree or any subdivision, this suggests a mistake in choosing to insert into this node");

                }
			} else if (debugRender)
            {
                Bounds.DrawAABB(Color.red);
                item.AABB.DrawAABB(Color.green);
            }

            return false;
        }

        public bool Remove(T item, bool debugRender = false)
        {
            AABB itemAABB = item.AABB;
            if (Bounds.Encloses(itemAABB))
            {
                if (!CanHaveChildren || !SubdivisionCanContainItem(item))
                {
                    return ObjectsInNode.Remove(item);
                }
                else
                {
                    var removed = false;

                    foreach (var child in Children)
                    {
                        if (child.Remove(item, debugRender))
                        {
                            removed = true;
                            break;
                        }
                    }

                    if (!removed) throw new NotImplementedException("The item could not be deleted into this tree or any subdivision, this suggests a mistake in choosing to delete the item from this node");

                    if (NumObjectsInChildren < MergeThreshold)
                    {
                        ObjectsInNode.AddRange(Children.SelectMany(c => c.ObjectsInNode));
                        Children.Clear();
                    }

                    return removed;
                }
            }
            else if (debugRender)
            {
                Bounds.DrawAABB(Color.red);
                item.AABB.DrawAABB(Color.green);
            }

            return false;
        }

        public void getAllContents(ref Collection<T> items){
			
			for (int i = 0; i<ObjectsInNode.Count; ++i) {
				items.Add(ObjectsInNode[i]);
			}
			
			for (int i = 0; i<Children.Count; ++i) {
				Children[i].getAllContents(ref items);
			}
		}

        public delegate bool AABBQuery(AABB nodeBounds);

		public void Query(AABBQuery query, ref Collection<T> items){
			//bounds.DrawAABB ();
			if (query(Bounds)){

				foreach (var itemInNode in ObjectsInNode.Where(o => query(o.AABB))){
					items.Add(itemInNode);
				}

				for (int i = 0; i<Children.Count; ++i){
					Children[i].Query(query, ref items);

				}
			}
		}

        //public void Query(Vector3 pos, ref Collection<T> items)
        //{
        //    //bounds.DrawAABB ();
        //    if (Bounds.ContainsPoint(pos))
        //    {

        //        int count = ObjectsInNode.Count;
        //        for (int i = 0; i < count; ++i)
        //        {
        //            items.Add(ObjectsInNode[i]);
        //            //Debug.DrawRay(bounds.center.FlattenVector()+new Vector3Custom(0,5,0),(getAABBFunc(objectsInNode[i]).center-bounds.center).FlattenVector(),Color.red,3f);
        //        }

        //        for (int i = 0; i < Children.Count; ++i)
        //        {
        //            //Debug.DrawRay(bounds.center.FlattenVector()+new Vector3Custom(0,5,0),(nodeList[children[i]].bounds.center-bounds.center).FlattenVector(),Color.green,3f);
        //            Children[i].GetOverlappingItems(pos, ref items);

        //        }
        //    }
        //}
    }
}

